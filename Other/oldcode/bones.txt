#pragma once

#include "glm/glm.hpp"
#include <vector>
#include <string>

#include "Utility/Debugger.h"

struct BoneStruct {
	int index = 0;
	std::string name;
	glm::mat4 matrix=glm::mat4(1);
	std::vector<int> children;
};

class Bone {
public:
	std::vector<Bone> children;
	std::string name;// Used for identification in animation
	int index = 0;
	glm::mat4 localMat=glm::mat4(1);

	/*
	Useless?
	*/
	glm::mat4 inverseMat=glm::mat4(1);

	Bone() {}

	void Build(int index, std::vector<BoneStruct>* structs) {
		this->index = index;
		name = structs->at(index).name;
		localMat = structs->at(index).matrix;
		for (int i : structs->at(index).children) {
			children.push_back(Bone());
			children.back().Build(i,structs);
		}
	}
	/*
	Useless?
	*/
	void calcInverseBindTransform(glm::mat4 parentBindTransform) {
		glm::mat4 bindT = parentBindTransform * localMat;
		inverseMat = glm::inverse(bindT);
		for (Bone child : children) {
			child.calcInverseBindTransform(bindT);
		}
	}
	void Log(int dent) {
		for (int i = 0; i < dent;i++) {
			bug::out < " ";
		}
		bug::out < "Bone "<index<bug::end;
		for (Bone& b : children) {
			b.Log(dent+1);
		}
	}
};
class BoneData {
public:
	Bone bone;
	int count=0;

	BoneData(){}

	void Build(std::vector<BoneStruct>* structs) {
		bone.index = 0;
		bone.name = structs->at(0).name;
		bone.localMat = structs->at(0).matrix;
		for (int i : structs->at(0).children) {
			bone.children.push_back(Bone());
			bone.children.back().Build(i,structs);
		}
	}

	/*
	Called in the end of fManager::LoadBone(...)
	*/
	void calcInverseBindTransform() {
		bone.calcInverseBindTransform(glm::mat4(1));
	}

	bool hasError = false;
};

int LoadBone(BoneData* da, std::string path) {
		path = "assets/bones/" + path + ".bone";
		bool debug = false;
		std::ifstream file(path, std::ios::binary);
		if (!file) {
			file.close();
			bug::out < bug::RED < "Cannot find file '" < path < "'\n";
			return NotFound;
		}
		ReadFromFile(&file, path);

		unsigned char boneCount;
		if (Read<unsigned char>(&boneCount)) return Corrupt;
		if (debug) bug::out < "Bone Count: " < (int)boneCount < bug::end;

		// Temporary Data Storage
		std::vector<BoneStruct> structs;

		// Acquire and Load Data
		for (int i = 0; i < boneCount; i++) {
			BoneStruct b;
			b.index = i;
			unsigned char nameLen;
			if (Read<unsigned char>(&nameLen)) return Corrupt;
			//if (debug) bug::out <"NameLen: "< (int)nameLen < bug::end;
			for (int j = 0; j < nameLen;j++) {
				char temp;
				if (Read<char>(&temp)) return Corrupt;
				b.name += temp;
			}
			if (debug) bug::out <"Name: "< b.name < bug::end;

			for (int x = 0; x < 4; x++){
				for (int y = 0; y < 4; y++) {
					if (Read<float>(&b.matrix[x][y])) return Corrupt;
				}
			}
			unsigned char count;
			if (Read<unsigned char>(&count)) return Corrupt;

			for (int j = 0; j < count;j++) {
				unsigned char ind;
				if (Read<unsigned char>(&ind)) return Corrupt;
				b.children.push_back(ind);
			}
			structs.push_back(b);
		}

		// BoneData Setup

		da->count = boneCount;

		da->Build(&structs);

		if(debug) da->bone.Log(0);

		da->calcInverseBindTransform();

		// Cleanup

		file.close();
		return Success;
	}

	#include "BoneComponent.h"

void BoneComponent::SetBone(BoneData* data) {
	if (data != nullptr) {
		bone = data;
		enabled = true;
	}
}
void BoneComponent::SetAnim(AnimationComponent* comp) {
	anim = comp;
}
float t = 0;
void BoneComponent::addToArray(glm::mat4* mat, Bone& bone, glm::mat4 parent) {
	glm::mat4 animMat = parent;
	if (anim->enabled) {
		//bug::out < bone.name < bug::end;
		animMat *= anim->GetTransform(bone.name);
		/*glm::mat4 mod = glm::mat4(1) 
			* glm::translate(glm::vec3(0, t, 0)) 
			* glm::rotate(0.5f * t, glm::vec3(0, 1, 0)) 
			* glm::scale(glm::vec3(1, 1, 1))
			;*/
	}
	mat[bone.index] = animMat*bone.inverseMat;
	
	for (Bone b : bone.children) {
		addToArray(mat, b, animMat);
	}
}
float vt = 1;
void BoneComponent::GetBoneTransforms(glm::mat4* mat) {
	addToArray(mat,bone->bone,glm::mat4(1));
	//mat[0] = glm::mat4(1);
	//mat[1] = mat[0] * glm::rotate(glm::radians(20.f*t), glm::vec3(1, 0, 0));
	//mat[2] = mat[1] * glm::rotate(glm::radians(20.f*t), glm::vec3(1, 0, 0));
	t += vt*0.016;
	if (t < 0||t>1)
		vt *= -1;
}

void main()
{
	//vec4 totalLocalPos = vec4(vPos,1);
	//vec4 totalNormal = vec4(vNormal,0);
	
	vec4 totalLocalPos = vec4(0);
	vec4 totalNormal = vec4(0);

	vec4 nColor = vColor;
	
	for (int i = 0; i < MAX_WEIGHTS; i++) {
		//if (vBones[i] == -1)// Bad?
		//	break;

		vec4 localPos = uBoneTransforms[int(vBones[i])] * vec4(vPos, 1);
		totalLocalPos += localPos * vWeights[i];

		vec4 worldNormal = uBoneTransforms[int(vBones[i])] * vec4(vNormal, 0);
		totalNormal += worldNormal * vWeights[i];
	}
	/*
	if (int(vBones[0]) == 0 || int(vBones[0]) == 1) {
		nColor = vec4(1, 1, 1, 1);
	} else {
		nColor = vec4(0, 1, 0, 1);
	}
	*/
	
	gl_Position = uProj * uTransform * totalLocalPos;// Add transform?
	fNormal = totalNormal.xyz;
	fColor = nColor;
};