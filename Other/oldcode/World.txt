// HEADER
#pragma once

#include "../FileHandler.h"
#include "../Objects/GameObject.h"

class World
{
public:
	World();
	World(std::string path);

	int SeedSize;
	float* SeedMap;

	float lastGenX;
	float lastGenZ;

	const static int LoadedArea=150;

	int seed=0;
	float scale=25;
	float heightScale = 15;
	float persistance=0.5; // Spikyness Higher value is smooth while lower value is spiky
	float lacunarity=2;
	int octaves=7;
	std::string name;
	
	void GenerateWorldMesh(float x,float y,float* vertices,int* indices,int count);

	float GetPerlin(float x, float y);
	float GetHeight(float x,float y);
	
	float GetNoise(float x, float y);
	float GetRegionH(float height);

	void GetRegion(float height, float* color);

	void LoadSeedMap(std::string path);

	float GetRandom(float x, float y);

	void LoadData(std::string data);

	//std::vector<Region> regions;
	std::vector<GameObject*> objects;
private:

};
// CPP
#include "World.h"

World::World()
{
	LoadSeedMap("data/seedmap.txt");
}
World::World(std::string settings)
{
	LoadSeedMap("data/seedmap.txt");
	
	/*
	std::vector<std::string> wdata = ReadFileList(path);
	if (wdata.size() > 0) {
		for (auto &line : wdata) {
			if (line[0] == '#')
				continue;
			
			std::vector<std::string> set = SplitString(line, " ");
			if (set[0] == "r") {
				std::string name=set[1];
				float x = std::stof(set[2]);
				float z = std::stof(set[3]);
				// FIX: Generate Mesh
				Region reg(name, x, z);
				//reg.AddTerrain(LoadObj("Region " + x + " " + z, GiveDir(path) + set[5]));
				regions.push_back(reg);
			}
			else if (set[0] == "p") {
				// FIX: Whole thing

				/*  JAVA CODE
				if (set[2].equals("Item")) {
					Item ite = Item.GenerateItem(set[1], set[2], set[4]);
					out.objects.Add(ite);
				}
				else if (set[2].equals("Entity")) {
					Entity ent = Entity.GenerateEntity(set[1], set[2], set[4]);
					out.objects.Add(ent);
				}
			}
		}
	}
	else {
		std::cout << "Created Empty World" << std::endl;
	}*/
}
void World::LoadData(std::string data) {
	std::vector<std::string> wdata = SplitString(data,"/w-/");
	for (std::string line : wdata) {
		std::vector<std::string> set = SplitString(line, "/w:/");
		if (set[0] == "name") {
			name = set[1];
		} else if (set[0] == "seed") {
			seed = std::stoi(set[1]);
		}
	}
}
void World::LoadSeedMap(std::string path) {
	int err;
	std::vector<std::string> map = ReadFileList(path,&err);
	SeedSize = map.size();

	SeedMap = new float[SeedSize*SeedSize];
	for (int i = 0; i < map.size();i++) {
		std::vector<std::string> set = SplitString(map[i], ",");
		for (int j = 0; j < set.size(); j++) {
			SeedMap[i*map.size() + j] = (float)std::stoi(set[j])/(map.size()*set.size());
		}
	}
}
void World::GenerateWorldMesh(float x,float z,float* vertices,int* indices,int count) {
	float half = count / 2;
	x = (int)x -(int)half;
	z = (int)z -(int)half;

	float nosX = GetRandom(seed*2, seed * 5) * 10000;
	float nosZ = GetRandom(seed * 5, seed*2) * 10000;

	float maxHeight = 0;
	float amplT=1;
	for (int i = 0; i < octaves; i++) {
		maxHeight += amplT;
		amplT *= persistance;
	}
	//std::cout << maxHeight << std::endl;
	/*float mint = 9999;
	float maxt = -9999;*/

	// World Generation
	float* map = new float[count*count];
	for (int i = 0; i < count; i++) {
		for (int j = 0; j < count; j++) {
			float amplitude = 1;
			float frequency = 1;
			float totalNoise=0;
			for (int o = 0; o < octaves;o++) {
				float noise = GetNoise(nosX+((x+i)/scale)*frequency, nosZ+((z+j)/scale)*frequency);
				totalNoise += noise * amplitude;
				/*if (noise < 0) {
					std::cout << "Low noise " << noise << std::endl;
				}*/
				amplitude *= persistance;
				frequency *= lacunarity;
			}
			/*if (totalNoise<mint) {
				mint = totalNoise;
			} else if (totalNoise>maxt) {
				maxt = totalNoise;
			}*/
			
			map[i*count + j] = totalNoise / maxHeight;
		}
	}

	//std::cout << "Max: " << maxt << " Mint: " << mint << std::endl;
	//std::cout << "Middle " << (map[(int)(half*count + half)]*10) << " other: " << GetHeight(x,z) <<  std::endl;
	for(int i = 0; i < count; i++) {
		for (int j = 0; j < count; j++) {
			// Position
			vertices[(i*count + j) * 10 + 0] = x+i;
			float noise = map[i*count+j];
			vertices[(i*count + j) * 10 + 1] = GetRegionH(noise)*heightScale;
			vertices[(i*count + j) * 10 + 2] = z+j;

			float color[3];
			GetRegion(noise,color);
			// Color
			vertices[(i*count + j) * 10 + 3] = color[0];
			vertices[(i*count + j) * 10 + 4] = color[1];
			vertices[(i*count + j) * 10 + 5] = color[2];
			vertices[(i*count + j) * 10 + 6] = 1;
			// Normal Reset - FIX: Remove this
			//vertices[(i*count + j) * 10 + 7] = 0;
			//vertices[(i*count + j) * 10 + 8] = 1;
			//vertices[(i*count + j) * 10 + 9] = 0;
		}
	}
	for (int i = 0; i < count-1; i++) {
		for (int j = 0; j < count-1; j++) {
			// 2 Triangles
			indices[(i*(count - 1) + j) * 3 * 2 + 0] = count * i + j;
			indices[(i*(count - 1) + j) * 3 * 2 + 1] = count * i + j +1;
			indices[(i*(count - 1) + j) * 3 * 2 + 2] = count * (i + 1) + j;
			indices[(i*(count - 1) + j) * 3 * 2 + 3] = count * i + j + 1;
			indices[(i*(count - 1) + j) * 3 * 2 + 4] = count * (i + 1) + j + 1;
			indices[(i*(count - 1) + j) * 3 * 2 + 5] = count * (i + 1) + j;
			
			// Normal
			// FIX: This can be optimized to not recalculate normal of vertex
			glm::vec3 norm = glm::normalize(glm::cross(
				glm::vec3(vertices[(i*count + j) * 10 + 0], vertices[(i*count + j) * 10 + 1], vertices[(i*count + j) * 10 + 2])-
				glm::vec3(vertices[(i*count + j+1) * 10 + 0], vertices[(i*count + j) * 10 + 1], vertices[(i*count + j+1) * 10 + 2]),
				glm::vec3(vertices[((i+1)*count + j) * 10 + 0], vertices[((i+1)*count + j) * 10 + 1], vertices[((i+1)*count + j) * 10 + 2])-
				glm::vec3(vertices[(i*count + j) * 10 + 0], vertices[(i*count + j) * 10 + 1], vertices[(i*count + j) * 10 + 2])
			));
			vertices[(i*count + j) * 10 + 7] = norm.x;
			vertices[(i*count + j) * 10 + 8] = norm.y;
			vertices[(i*count + j) * 10 + 9] = norm.z;
		}
	}
	delete map;
}
float World::GetRegionH(float height) {
	if (height<0.18) {
		return 0.09+0.09*(height/0.18);
	}else if (height < 0.26) {
		return 0.18+0.04+ 0.04*((height-0.18) / (0.14));
	}else if (height > 0.6 && height < 0.7) {
		return 0.3 + height/2;
	} else if (height > 0.7 && height < 1) {
		return 0.35 + height/2;
	}
	return height;
}
void World::GetRegion(float height, float* color) {
	if (height<0.18) {
		color[0] = 0.1;
		color[1] = 0.1;
		color[2] = 0.4;
	}else if (height < 0.26) {
		color[0] = 0.3;
		color[1] = 0.3;
		color[2] = 0.7;
	}else if (height < 0.34) {
		color[0] = 0.7;
		color[1] = 0.7;
		color[2] = 0.5;
	}else if (height < 0.40) {
		color[0] = 0.4;
		color[1] = 0.7;
		color[2] = 0.4;
	}else if (height < 0.50) {
		color[0] = 0.3;
		color[1] = 0.6;
		color[2] = 0.3;
	}else if (height < 0.60) {
		color[0] = 0.35;
		color[1] = 0.3;
		color[2] = 0.3;
	}else if (height < 0.70) {
		color[0] = 0.25;
		color[1] = 0.2;
		color[2] = 0.2;
	}else if (height < 1) {
		color[0] = 0.9;
		color[1] = 0.9;
		color[2] = 0.9;
	}
}
float World::GetRandom(float x,float y) {
	int x0 = (int)(7*x+y) % SeedSize;
	int y0 = (int)(3*y+2*x) % SeedSize;
	int ind = (x0 < 0 ? SeedSize + x0 : x0)*SeedSize + (y0 < 0 ? SeedSize + y0 : y0);
	if(ind<0)
		std::cout << ind << std::endl;
	return SeedMap[ind]; 
}
float World::GetHeight(float x,float z) {
	float nosX = GetRandom(seed, seed * 2) * 1000;
	float nosZ = GetRandom(seed * 2, seed) * 1000;

	float maxHeight = 0;
	float amplT = 1;
	for (int i = 0; i < octaves; i++) {
		maxHeight += amplT;
		amplT *= persistance;
	}
	float amplitude = 1;
	float frequency = 1;
	float totalNoise = 0;
	for (int o = 0; o < octaves; o++) {
		float noise = GetNoise(nosX + x / scale * frequency, nosZ + z / scale * frequency);
		totalNoise += noise * amplitude;
		amplitude *= persistance;
		frequency *= lacunarity;
	}
	return GetRegionH(totalNoise/maxHeight)* heightScale;
}
float World::GetNoise(float x, float y) {
	int nSampleX1 = (int)x;
	int nSampleY1 = (int)y;

	int nSampleX2, nSampleY2;
	float fBlendX, fBlendY;

	if (x < 0) {
		nSampleX2 = (nSampleX1 - 1);
		fBlendX = (float)(nSampleX1 - x);
	}
	else {
		nSampleX2 = (nSampleX1 + 1);
		fBlendX = (float)(x - nSampleX1);
	}
	if (y < 0) {
		nSampleY2 = (nSampleY1 - 1);
		fBlendY = (float)(nSampleY1 - y);
	}
	else {
		nSampleY2 = (nSampleY1 + 1);
		fBlendY = (float)(y - nSampleY1);
	}

	float fSampleT = lerp(GetRandom(nSampleX1, nSampleY1), GetRandom(nSampleX2, nSampleY1), fBlendX);
	float fSampleB = lerp(GetRandom(nSampleX1, nSampleY2), GetRandom(nSampleX2, nSampleY2), fBlendX);

	float fNoise = (fBlendY * (fSampleB - fSampleT) + fSampleT);
	if (fNoise < 0) {
		//std::cout << "Low Noise XZ:" << x << " " << y << " Randoms: "<< GetRandom(nSampleX1,nSampleY1) << " " << GetRandom(nSampleX2, nSampleY1) << " " << GetRandom(nSampleX1, nSampleY2) << " " << GetRandom(nSampleX2, nSampleY2) << std::endl;
	}
	return fNoise;
}
float World::GetPerlin(float x,float y) {
	/*
	float fNoise = 0;
	float fScaleAcc = 0;
	float fScale = 1;
	for (int o = 0; o < octaves; o++) {
		int nPitch = frequency >> o;
		if (nPitch == 0) {
			nPitch = 1;
		}
		int nSampleX1 = ((int)x / nPitch) * nPitch;
		int nSampleY1 = ((int)y / nPitch) * nPitch;

		int nSampleX2, nSampleY2;
		float fBlendX, fBlendY;

		if (x < 0) {
			nSampleX2 = (nSampleX1 - nPitch);
			fBlendX = (float)(nSampleX1 - x) / (float)nPitch;
		}
		else {
			nSampleX2 = (nSampleX1 + nPitch);
			fBlendX = (float)(x - nSampleX1) / (float)nPitch;
		}
		if (y < 0) {
			nSampleY2 = (nSampleY1 - nPitch);
			fBlendY = (float)(nSampleY1 - y) / (float)nPitch;
		}
		else {
			nSampleY2 = (nSampleY1 + nPitch);
			fBlendY = (float)(y - nSampleY1) / (float)nPitch;
		}

		float fSampleT = lerp(GetRandom(nSampleX1, nSampleY1), GetRandom(nSampleX2, nSampleY1), fBlendX);
		float fSampleB = lerp(GetRandom(nSampleX1, nSampleY2), GetRandom(nSampleX2, nSampleY2), fBlendX);

		fScaleAcc += fScale;
		fNoise += (fBlendY * (fSampleB - fSampleT) + fSampleT) * fScale;
		fScale = fScale / amplitude;
	}
	
	return fNoise / fScaleAcc;*/
	return 0;
}