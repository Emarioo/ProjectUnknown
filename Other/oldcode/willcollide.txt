glm::vec3 GameObject::WillCollide(GameObject* o1, float delta) {
		std::vector<Collision*> list0 = GetColliders();
		std::vector<Collision*> list1 = o1->GetColliders();
		glm::vec3 out = velocity;

		std::vector<Collision*>* plist0 = &list0;
		std::vector<Collision*>* plist1 = &list1;

		int times = 0;
		while (times++ < 2) {
			if (times == 2) {
				plist0 = &list1;
				plist1 = &list0;
				out *= -1;
			}
			for (Collision* c0 : *plist0) {
				if (c0->coll == nullptr)
					continue;
				for (Collision* c1 : *plist1) {
					if (c1->coll == nullptr)
						continue;
					bool hasHit = true;
					int limit = 0;
					while (hasHit && limit++ < 5) {
						hasHit = false;
						glm::vec3 newOut;
						float shortest = 9999;
						for (int i = 0; i < c1->coll->quad.size() / 4; i++) {

							// Get 4 points for quad
							glm::vec3 A = c1->points[c1->coll->quad[i * 4]];
							glm::vec3 B = c1->points[c1->coll->quad[i * 4 + 1]];
							glm::vec3 C = c1->points[c1->coll->quad[i * 4 + 2]];
							glm::vec3 D = c1->points[c1->coll->quad[i * 4 + 3]];

							// Front of quad
							glm::vec3 up = glm::normalize(glm::cross(B - A, C - A));

							// Normal of the edges
							glm::vec3 AB = glm::normalize(glm::cross(up, A - B));
							glm::vec3 BC = glm::normalize(glm::cross(up, B - C));
							glm::vec3 CD = glm::normalize(glm::cross(up, C - D));
							glm::vec3 DA = glm::normalize(glm::cross(up, D - A));

							for (int j = 0; j < c0->points.size(); j++) {
								// Starting Point
								glm::vec3 M = c0->points[j];
								// Ending Point
								glm::vec3 N = c0->points[j] + out * delta;

								// Which side of plane is point j before and after velocity
								float f0 = glm::dot(M - A, up);
								float f1 = glm::dot(N - A, up);

								// If d0 and d1 is same then no collision
								if (f0 >= 0 && f1 >= 0 || f0 < 0 && f1 < 0) {
									continue;
								}

								// Line's intersection point to quad plane
								glm::vec3 P = IntersectPlane(A, up, M, N);

								// Values for wether P is outside of quad plane. (negative inside, positive outside)
								float a = glm::dot(AB, P - B);
								float b = glm::dot(BC, P - C);
								float c = glm::dot(CD, P - D);
								float d = glm::dot(DA, P - A);

								// if P is inside then calculate how much.
								if (a < 0 && b < 0 && c < 0 && d < 0) {
									float l = glm::length(P - M);

									// take the shortest intersection point
									if (l < shortest) {
										shortest = l;
										hasHit = true;

										// Closest point to plane
										glm::vec3 U = IntersectPlane(A, up, M, M + up);
										float mn = glm::length(out * delta);
										float um = glm::length(U - M);

										// Point beyond U
										glm::vec3 V = up * (-mn * um / l);

										newOut = (out * delta - V) / delta;
									}
								}
							}
						}
						if (hasHit)
							out = newOut;

					}
				}
			}
		}
		return out * -1.f;
	}