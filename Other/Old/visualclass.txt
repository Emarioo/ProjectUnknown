// visual.h
#pragma once
/*
#define GLEW_STATIC
#include <GL/glew.h>
#include <GLFW/glfw3.h>
*/
#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtx/transform.hpp"
#include "glm/gtc/type_ptr.hpp"

#include <iostream>
#include <map>

#include "../Rendering/Renderer.h"
#include "BufferContainer.h"
#include "Rendering/Shader.h"
#include "Rendering/Texture.h"
#include "Rendering/Text.h"

#include "Objects/GameObject.h"

//#include "Gui/ISquare.h"
//#include "Gui/IButton.h"
#include "Gui/IInput.h"
#include <Windows.h>

/*
#define ASSERT(x) if (!(x))__debugbreak();
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x, __FILE__,__LINE__));

void GLClearError();
bool GLLogCall(const char* function, const char* file, int line);
*/
class Visual {
public:
	Visual();
	void Init();
	void LoadPreMeshes();
	void SetCamera(glm::vec3 pos, glm::vec3 rot);

	Renderer renderer;

	void Update();
	void Draw(std::vector<GameObject*> objects);
	Mesh* GetMesh(std::string meshid);
	std::map<std::string, Mesh> preMeshes;
	void DrawMesh(std::string meshid);

	// FIX: Delete Section?
	static void WinFocusInput(GLFWwindow* window, int focus);
	static void SetMouseLock(bool f);
	static bool MouseLock;
	static bool HasFocus;
	bool MouseInWindow();

	static void KeyCallback(GLFWwindow* window,int key,int scancode,int action,int mods);
	static void MouseCallback(GLFWwindow* window,int button,int action,int mods);
	static void CursorCallback(GLFWwindow* window,double mx,double my);

	static double mouseX,mouseY;

	int STAGE_MENU = 0;
	int LOGIN_M = 0, START_M = 1, SINGLE_M = 2, MULTI_M = 3, GAME_M = 4; // Final static values
	ISquare sBack;
	IInput iUser;
	IInput iKey;
	IButton bLogin;
	IButton bSingle;
	IButton bMulti;

private:
	glm::mat4 projMatrix;
	float sens=0.5f;
	static float centerX, centerY;
};
// visual.cpp
#include "Visual.h"
/*
void GLClearError() {
	while (glGetError() != GL_NO_ERROR);
}
bool GLLogCall(const char* function, const char* file, int line)
{
	// Fix: Translate "error" to words
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << ") " << function << " " << file << ":" << line << std::endl;
		return false;
	}
	return true;
}
*/
double Visual::mouseX = 0;
double Visual::mouseY = 0;
void Visual::Update() {
	if (STAGE_MENU == GAME_M) {

	}
	else {
		
		if (STAGE_MENU == LOGIN_M) {
			POINT p;
			GetCursorPos(&p);
			if (bLogin.Clicked(p.x,p.y)) {
				STAGE_MENU = START_M;
			} else if (iUser.Clicked(p.x,p.y)) {

			} else if (iKey.Clicked(p.x, p.y)) {

			}
		} else if (STAGE_MENU == START_M) {

		} else if (STAGE_MENU == SINGLE_M) {

		} else if (STAGE_MENU == MULTI_M) {

		}
	}
}
void Visual::KeyCallback(GLFWwindow* window,int key,int scancode, int action, int mods) {
	//std::cout << "Key " << key << " " << scancode << " " << action << " " << mods << std::endl;
}
void Visual::MouseCallback(GLFWwindow* window,int button, int action, int mods) {
	//std::cout << "MButton " << button << " " << action << " " << mods << std::endl;
	
}
void Visual::CursorCallback(GLFWwindow* window, double mx, double my) {
	//std::cout << "Mouse " << mx << " " << my << std::endl;
	mouseX = mx;
	mouseY = my;
}
void Visual::Draw(std::vector<GameObject*> objects) {
	// Game
	/*
	renderer.GameC.Bind();
	for (int i = 0; i < objects.size(); i++) {
		objects.at(i)->Draw();
	}
	*/
	// GUI
	if (STAGE_MENU == GAME_M) {

	}
	else {
		if (STAGE_MENU == LOGIN_M) {
			renderer.FaceT.Bind();
			iUser.Draw(&renderer.FaceT);
			iKey.Draw(&renderer.FaceT);
			bLogin.Draw(&renderer.FaceT);
		}else if (STAGE_MENU == START_M) {

		}else if (STAGE_MENU == MULTI_M) {

		}else if (STAGE_MENU == SINGLE_M) {

		}else if (STAGE_MENU == MULTI_M) {

		}
		sBack.Draw(&renderer.FaceT);
	}

}
Mesh* Visual::GetMesh(std::string meshid) {
	return &preMeshes[meshid];
}
void Visual::LoadPreMeshes() {
	preMeshes["rock"] = Mesh("assets/models/rock.txt");
}
void Visual::DrawMesh(std::string meshid) {
	BufferContainer* con = &GetMesh(meshid)->container;
	
	renderer.Transform(con->shaderType,glm::mat4(1));// POSITION
	con->Draw();
}

float Visual::centerX = 0;
float Visual::centerY = 0;
bool Visual::HasFocus = true;
bool Visual::MouseLock = false;

Visual::Visual()
: projMatrix(glm::perspective(glm::radians(90.0f), (1200.0f/800.0f), 0.1f, 400.0f)) {
	
}
void Visual::Init()
{
	/*
	if (!glfwInit()) {
		std::cout << "Not Init Window!" << std::endl;
		return;
	}
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	GLFWwindow* window = glfwCreateWindow(1200, 800, "ProjectMMORPG", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		std::cout << "Terminate Window!" << std::endl;
		return;
	}
	glfwMakeContextCurrent(window);
	if (glewInit() != GLEW_OK) {
		std::cout << "Error!" << std::endl;
		return;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;

	glfwSetWindowFocusCallback(window, WinFocusInput);

	realShader = Shader("assets/shaders/Reality.shader");
	interShader = Shader("assets/shaders/Interface.shader");
	
	unsigned int inde[]{
		2,1,0,
		2,3,1
	};
	float verts[]{
		-2,-1,-2,1,1,1,1,
		2,-1,-2,1,1,1,1,
		-2,-1,2,1,1,1,1,
		2,-1,2,1,1,1,1
	};
	unsigned int inde2[]{
		0,1,2,
		1,3,2
	};
	float verts2[]{
			-1,-1,0,0,
			0,-1,1,0,
			-1,0,0,1,
			0,0,1,1
	};
	BufferContainer re1(true);
	re1.Setup(verts2, 4*4, inde2, 6);
	re1.SetAttrib(0, 4, 4, 0);
	
	unsigned int VA, VB, IB;
	GLCall(glGenVertexArrays(1, &VA));
	GLCall(glBindVertexArray(VA));

	GLCall(glGenBuffers(1, &VB));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, VB));
	GLCall(glBufferData(GL_ARRAY_BUFFER, sizeof(verts2), verts2, GL_DYNAMIC_DRAW));

	glEnableVertexArrayAttrib(VA, 0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float),0);

	GLCall(glGenBuffers(1, &IB));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IB));
	GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, 3 * sizeof(unsigned int), inde2, GL_DYNAMIC_DRAW));
	

	Font fontt("assets/textures/CustomFont.png");
	Text textt("!ABC +=> 123",64,&fontt);

	Texture png("assets/textures/tree.png");

	SInterface sInterface = SInterface();

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glEnable(GL_CULL_FACE);
	
	//glDepthMask(GL_FALSE);
	glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	//realShader.Bind();
	//glUniformMatrix4fv(glGetUniformLocation(realShader.programID, "transform"), 1, GL_FALSE, glm::value_ptr(glm::mat4(1)));
	
	

	float time=0;
	
	bool keyEsc = false;
	while (!glfwWindowShouldClose(window))
	{
		
		if (HasFocus) {
			//if (MouseInWindow()) {SetMouseLock(true);}
			if (GetKeyState(VK_ESCAPE) < 0) {
				if (!keyEsc) {
					SetMouseLock(!MouseLock);
				}
				keyEsc = true;
			}
			else {
				keyEsc = false;
			}
			// Camera Rotation
			if (MouseLock) {
				POINT mouse;
				GetCursorPos(&mouse);
				int dx = mouse.x - centerX;
				int dy = mouse.y - centerY;
				if (dx != 0 || dy != 0) {
					int wx;
					int wy;
					int wsx;
					int wsy;
					glfwGetWindowPos(window, &wx, &wy);
					glfwGetWindowSize(window, &wsx, &wsy);
					centerX = wx + wsx / 2;
					centerY = wy + wsy / 2;

					//manage.player->rotation.y -= glm::degrees(glm::asin(dx / ((float)wsx / 2)))*sens;
					//manage.player->rotation.x -= glm::degrees(glm::asin(dy / ((float)wsy / 2)))*sens;
					SetCursorPos(centerX, centerY);
				}
			}
			//manage.player->Update();
			//std::cout << manage.player->rotation.x << std::endl;
			//UpdateCamera();
		}
		
		time++;
		if (time == 120) {
			float verts2[]{
				0,0,0,0,
				0,-1,0,1,
				1,0,1,0
			};
			re1.VBuff(0,3*4,verts2);
			//glBindBuffer(GL_ARRAY_BUFFER,re1.vb);
			//glBufferSubData(GL_ARRAY_BUFFER,0,3*4*sizeof(float),verts2);
		}
	
		glClearColor(0.1f, 0.1f, 0.1f, 1);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		// 3D World Render
		//realShader.Bind();
		//newtest.Draw();

		// 2D Screen Render
		
		interShader.Bind();
		png.Bind();
		re1.Draw();
		
		
		GLCall(glBindVertexArray(VA));
		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IB));
		GLCall(glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, nullptr));
		
		textt.DrawString(interShader);

		
		
		renderer.DrawWorld();
		if (distance(player.position.x, player.position.z, currentWorld.lastGenX, currentWorld.lastGenZ) > 30) {
			renderer.UpdateWorld(&currentWorld, player.position);
			currentWorld.lastGenX = player.position.x;
			currentWorld.lastGenZ = player.position.z;
		}
		for (PhysicalObject& po : currentWorld.objects) {
			for (Bone& b : po.model) {
				//renderer.DrawBone(b);
			}
		}


		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glfwTerminate();
	*/

	glfwSetKeyCallback(renderer.window, KeyCallback);
	glfwSetMouseButtonCallback(renderer.window, MouseCallback);
	glfwSetCursorPosCallback(renderer.window, CursorCallback);

	// Init Gui
	sBack.SetTex("assets/textures/Start_Menu.png");
	sBack.SetDim(-1, 1, 2, 2);

	iUser.SetTex("assets/textures/btn_user.png");
	iUser.SetDim(-0.4,0.2,0.8,0.25);
	
	iKey.SetTex("assets/textures/btn_key.png");
	iKey.SetDim(-0.4,-0.1,0.8,0.25);

	bLogin.SetTex("assets/textures/btn_login.png");
	bLogin.SetDim(-0.2,-0.4,0.4,0.3);

	/*bSingle.SetTex();
	bSingle.SetDim();

	bMulti.SetTex();
	bMulti.SetDim();*/
}

void Visual::SetCamera(glm::vec3 pos, glm::vec3 rot) {
	glm::mat4 trans = glm::translate(glm::mat4(1.0f), pos) *
		glm::rotate(glm::mat4(1.0f), glm::radians(rot.y), glm::vec3(0, 1, 0))*
		glm::rotate(glm::mat4(1.0f), glm::radians(rot.x), glm::vec3(1, 0, 0));

	// BINDING BEFORE?
	renderer.GameC.Bind();
	renderer.GameC.SetUniformMat4fv("uProj", projMatrix * glm::inverse(trans));
	renderer.GameT.Bind();
	renderer.GameT.SetUniformMat4fv("uProj", projMatrix * glm::inverse(trans));
}
void Visual::WinFocusInput(GLFWwindow* window, int focus) {

	HasFocus = focus;
	if (!focus) {
		SetMouseLock(false);
	}
}
bool Visual::MouseInWindow() {
	/*
	if (GetKeyState(VK_LBUTTON) < 0) {
		int x = 0;
		int y = 0;
		int w = 0;
		int h = 0;
		//glfwGetWindowPos(renderer.window, &x, &y);
		//glfwGetWindowSize(renderer.window, &w, &h);
		POINT p;
		GetCursorPos(&p);

		return p.x > x&&p.x<x + w && p.y>y&&p.y < y + h;
	}*/
	return false;
}
void Visual::SetMouseLock(bool f) {
	if (MouseLock == f)
		return;
	/*
	MouseLock = f;
	ShowCursor(!f);
	if (f) {
		int wx = 0;
		int wy = 0;
		int wsx = 0;
		int wsy = 0;
		//glfwGetWindowPos(renderer.window, &wx, &wy);
		//glfwGetWindowSize(renderer.window, &wsx, &wsy);
		centerX = wx + wsx / 2;
		centerY = wy + wsy / 2;
		SetCursorPos(centerX, centerY);
	}*/
}